import type {NextPage} from 'next'
import Head from 'next/head'
import Image from 'next/image'
import styles from '../styles/Home.module.css'
import {useEffect} from "react";
import {Button} from "@mui/material";
import {BrowserWallet, ForgeScript, Transaction} from "@martifylabs/mesh";
import {NativeScript} from "@emurgo/cardano-serialization-lib-nodejs";
import * as CardanoWasm from "@emurgo/cardano-serialization-lib-browser"
import * as MessageSigning from "@emurgo/cardano-message-signing-browser"
import parseAsHeaders from "parse-headers";


const Home: NextPage = () => {
    useEffect(() => {

    }, [])

    async function signAndVerify(wallet: { signData: (arg0: any, arg1: any) => any; }, address: any, arbitraryMessage: any){
        const signedMessage = await wallet.signData(address, arbitraryMessage);
        console.error("signedMessage", signedMessage);

        // @ts-ignore
        const message = MessageSigning.COSESign1.from_bytes(Buffer.from(Buffer.from(signedMessage.signature, "hex"), "hex"));
        const headermap = message.headers().protected().deserialized_headers();
        // @ts-ignore

        const coseKey = MessageSigning.COSEKey.from_bytes(Buffer.from(signedMessage.key, "hex"));

        // @ts-ignore
        const publicKey = CardanoWasm.PublicKey.from_bytes(coseKey.header(MessageSigning.Label.new_int(MessageSigning.Int.new_negative(MessageSigning.BigNum.from_str("2")))).as_bytes());

        // const edSig = CardanoWasm.Ed25519Signature.from_bytes(Buffer.from(signedMessage.signature, "hex"));

        const data = message.signed_data().to_bytes();
        const body_from_token = Buffer.from(data).toString("utf-8");

        const ed25519Sig = CardanoWasm.Ed25519Signature.from_bytes(
            message.signature()
        );

        console.error("coseKey, publicKey", {
            coseKey,
            publicKey,
            message,
            data,
            ed25519Sig,
            body_from_token
        });

        if (!publicKey.verify(data, ed25519Sig)) {
            throw new Error(
                `Message integrity check failed (has the message been tampered with?)`
            );
        }

        const parsed_body = parseAsHeaders(body_from_token);

        // @ts-ignore
        if (parsed_body["expire-date"] && new Date(parsed_body["expire-date"]) < new Date()) {
            throw new Error("Token expired");
        }
        alert("message verified!")
    }

    async function onMint() {
        console.log("minting started")
        // connect to a wallet
        const wallet = await BrowserWallet.enable('eternl');

        const usedAddresses = await wallet.getUsedAddresses();

        let addressToUse = "addr_test1qqz8sy4d438czudh8dvlgacj27m2fy23z7v4275lknfy0km5a82wje8kfd63n5u2wrea98aq7cdaty25t2sc8vkt2rxsca56y9";
        let recipient = "addr_test1qp3xhvczczsn62qemfgekvs78hvw8talcefz88n4d6kqaut5a82wje8kfd63n5u2wrea98aq7cdaty25t2sc8vkt2rxsfmenp3";

        let address = null;
        for (const usedAddress of usedAddresses) {
            if (usedAddress === addressToUse) {
                address = usedAddress;
            }
        }
        if (!address) {
            throw new Error("no useful address found")
        }
        const forgingScript = ForgeScript.withOneSignature(address);

        // const nativeForgingScript = ForgeScript.fromNativeScript(NativeScript.)

        const tx = new Transaction({initiator: wallet});

        // define asset#1 metadata
        const assetMetadata1 = {
            "name": "PORCOLADRO",
            "image": "ipfs://QmRzicpReutwCkM6aotuKjErFCUD213DpwPq6ByuzMJaua",
            "mediaType": "image/jpg",
            "description": "This NFT is minted by Mesh (https://mesh.martify.io/)."
        };
        const asset1 = {
            assetName: 'PORCOLADRO',
            assetQuantity: '1',
            metadata: assetMetadata1,
            label: '721',
            recipient: {
                address: recipient,
            },
        };
        tx.mintAsset(
            forgingScript,
            asset1,
        );

        const unsignedTx = await tx.build();
        const signedTx = await wallet.signTx(unsignedTx).catch(e => {
            console.error("minting error", e)
        });
        if(signedTx){
            const txHash = await wallet.submitTx(signedTx).catch(e => {
                console.error("minting error", e)
            });
            console.log("minting done", txHash)
        }
    }

    return (
        <div className={styles.container}>
            <Head>
                <title>Create Next App</title>
                <meta name="description" content="Generated by create next app"/>
                <link rel="icon" href="/favicon.ico"/>
            </Head>

            <main className={styles.main}>
                Minta il PORCO *** LADRO NFT.
                <Button onClick={onMint}>mintalo ora, ccoddio</Button>
            </main>

            <footer className={styles.footer}>
                <a
                    href="https://vercel.com?utm_source=create-next-app&utm_medium=default-template&utm_campaign=create-next-app"
                    target="_blank"
                    rel="noopener noreferrer"
                >
                    Powered by{' '}
                    <span className={styles.logo}>
            <Image src="/vercel.svg" alt="Vercel Logo" width={72} height={16}/>
          </span>
                </a>
            </footer>
        </div>
    )
}

export default Home
